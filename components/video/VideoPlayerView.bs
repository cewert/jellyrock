import "pkg:/source/enums/SubtitleSelection.bs"
import "pkg:/source/roku_modules/log/LogMixin.brs"
import "pkg:/source/utils/config.bs"
import "pkg:/source/utils/misc.bs"
import "pkg:/source/utils/queueBackdropHelper.bs"
import "pkg:/source/utils/session.bs"
import "pkg:/source/utils/trickplay.bs"

' Child index for position label in Roku's built-in trickPlayBar component
' The trickPlayBar is part of the Video node and doesn't expose child IDs,
' so we must access by index. Fallback search logic exists if Roku changes the structure.
const TRICKPLAYBAR_POSITION_LABEL_INDEX = 8

sub init()
  m.log = log.Logger("VideoPlayerView")
  ' Hide the overhang on init to prevent showing 2 clocks
  m.top.getScene().findNode("overhang").visible = false
  userSettings = m.global.user.settings
  m.currentItem = m.global.queueManager.callFunc("getCurrentItem")
  m.originalClosedCaptionState = invalid

  m.top.id = m.currentItem.id
  m.top.seekMode = "accurate"

  m.playbackEnum = {
    null: -10
  }

  ' Load meta data
  m.LoadMetaDataTask = CreateObject("roSGNode", "LoadVideoContentTask")
  m.LoadMetaDataTask.itemId = m.currentItem.id
  m.LoadMetaDataTask.itemType = m.currentItem.type
  m.LoadMetaDataTask.selectedAudioStreamIndex = m.currentItem.selectedAudioStreamIndex
  m.LoadMetaDataTask.observeField("content", "onVideoContentLoaded")
  m.LoadMetaDataTask.control = "RUN"

  m.chapterList = m.top.findNode("chapterList")
  m.chapterMenu = m.top.findNode("chapterMenu")
  m.chapterContent = m.top.findNode("chapterContent")
  m.osd = m.top.findNode("osd")
  m.osd.observeField("action", "onOSDAction")
  m.trickplayCarousel = m.top.findNode("trickplayCarousel")

  ' Trickplay seek position tracking - we parse Roku's trickPlayBar text to get
  ' the authoritative seek position and sync our carousel to it
  m.isTrackingSeek = false
  m.carouselHiddenForSeek = false ' Track when carousel is hidden during seek confirmation
  m.lastSentThumbnailIndex = -1 ' Dedup thumbnail index updates to prevent double-rendering at tile boundaries

  m.playbackTimer = m.top.findNode("playbackTimer")
  m.bufferCheckTimer = m.top.findNode("bufferCheckTimer")
  m.top.observeField("content", "onContentChange")
  m.top.observeField("selectedSubtitle", "onSubtitleChange")
  m.top.observeField("audioIndex", "onAudioIndexChange")

  ' Custom Caption Function
  m.top.observeField("allowCaptions", "onAllowCaptionsChange")

  m.playbackTimer.observeField("fire", "ReportPlayback")
  m.bufferPercentage = 0 ' Track whether content is being loaded
  m.playReported = false
  m.top.transcodeReasons = []
  m.bufferCheckTimer.duration = 30

  if userSettings.uiDesignHideClock = true
    clockNode = findNodeBySubtype(m.top, "clock")
    if isValid(clockNode[0]) then clockNode[0].parent.removeChild(clockNode[0].node)
  end if

  'Play Next Episode button
  m.notifyButtons = m.top.findNode("notifyButtons")
  m.nextEpisodeButton = m.top.findNode("nextEpisode")
  m.nextEpisodeButton.setFocus(false)
  m.nextupbuttonseconds = userSettings.playbackNextUpButtonSeconds

  m.showNextEpisodeButtonAnimation = m.top.findNode("showNextEpisodeButton")
  m.hideNextEpisodeButtonAnimation = m.top.findNode("hideNextEpisodeButton")

  m.checkedForNextEpisode = false
  m.getNextEpisodeTask = createObject("roSGNode", "GetNextEpisodeTask")
  m.getNextEpisodeTask.observeField("nextEpisodeData", "onNextEpisodeDataLoaded")

  constants = m.global.constants

  m.top.retrievingBar.filledBarBlendColor = constants.colorSecondary

  m.top.bufferingBar.filledBarBlendColor = constants.colorSecondary

  m.top.trickPlayBar.filledBarBlendColor = constants.colorSecondary
  m.top.trickPlayBar.thumbBlendColor = constants.colorTextPrimary
  m.top.trickPlayBar.textColor = constants.colorTextPrimary
  m.top.trickPlayBar.currentTimeMarkerBlendColor = constants.colorTextPrimary

  ' Hook into trickPlayBar's internal position text to sync carousel with Roku's authoritative seek position
  ' Use defensive search to handle different Roku OS versions
  m.trickPlayBarPositionText = findTrickPlayBarPositionLabel()
  if isValid(m.trickPlayBarPositionText)
    m.trickPlayBarPositionText.observeField("text", "onTrickPlayBarTextChange")
    m.log.info("TrickPlayBar position text observer attached successfully")
  else
    m.log.warn("TrickPlayBar position text not found - carousel will only update during playback, not during scrubbing")
  end if
end sub

' findTrickPlayBarPositionLabel: Defensively finds the position text label in trickPlayBar
'
' Tries multiple strategies to find the Label that displays seek position:
' 1. Expected child index (8) - fast path for current Roku OS
' 2. Search for FIRST Label child - position text comes before remaining time
' 3. Return invalid if not found - feature gracefully degrades
'
' @return {dynamic} - Label node or invalid if not found
function findTrickPlayBarPositionLabel() as dynamic
  if not isValid(m.top.trickPlayBar) then return invalid

  ' Strategy 1: Try expected child index (current Roku structure)
  child = m.top.trickPlayBar.getChild(TRICKPLAYBAR_POSITION_LABEL_INDEX)
  if isValid(child) and child.subtype() = "Label"
    m.log.debug("Found trickPlayBar position label at expected index", TRICKPLAYBAR_POSITION_LABEL_INDEX)
    return child
  end if

  ' Strategy 2: Search for FIRST Label child (position comes before remaining time)
  childCount = m.top.trickPlayBar.getChildCount()
  m.log.warn("Position label not at expected index, searching for first Label child", "count", childCount)

  for i = 0 to childCount - 1
    child = m.top.trickPlayBar.getChild(i)
    if isValid(child) and child.subtype() = "Label"
      m.log.info("Found trickPlayBar position label via search", "index", i)
      return child
    end if
  end for

  ' Strategy 3: Not found - graceful degradation
  m.log.error("Could not find trickPlayBar position label - carousel sync during scrub will not work")
  return invalid
end function

' handleChapterSkipAction: Handles user command to skip chapters in playing video
'
sub handleChapterSkipAction(action as string)
  if not isValidAndNotEmpty(m.chapters) then return

  currentChapter = getCurrentChapterIndex()

  if action = "chapternext"
    gotoChapter = currentChapter + 1
    ' If there is no next chapter, exit
    if gotoChapter > m.chapters.count() - 1 then return

    m.top.seek = m.chapters[gotoChapter].StartPositionTicks / 10000000#
    return
  end if

  if action = "chapterback"
    gotoChapter = currentChapter - 1
    ' If there is no previous chapter, restart current chapter
    if gotoChapter < 0 then gotoChapter = 0

    m.top.seek = m.chapters[gotoChapter].StartPositionTicks / 10000000#
    return
  end if
end sub

' handleItemSkipAction: Handles user command to skip items
'
' @param {string} action - skip action to take
sub handleItemSkipAction(action as string)
  if action = "itemnext"
    queueManager = m.global.queueManager

    ' If there is something next in the queue, play it
    if queueManager.callFunc("getPosition") < queueManager.callFunc("getCount") - 1
      m.top.control = "stop"
      m.global.sceneManager.callFunc("clearPreviousScene")
      queueManager.callFunc("moveForward")
      updateQueueBackdrop()
      queueManager.callFunc("playQueue")
    end if

    return
  end if

  if action = "itemback"
    queueManager = m.global.queueManager

    ' If there is something previous in the queue, play it
    if queueManager.callFunc("getPosition") > 0
      m.top.control = "stop"
      m.global.sceneManager.callFunc("clearPreviousScene")
      queueManager.callFunc("moveBack")
      updateQueueBackdrop()
      queueManager.callFunc("playQueue")
    end if

    return
  end if
end sub

' handleHideAction: Handles action to hide OSD menu
'
' @param {boolean} resume - controls whether or not to resume video playback when sub is called
'
sub handleHideAction(resume as boolean)
  m.osd.visible = false
  m.chapterList.visible = false
  m.osd.showChapterList = false
  m.chapterList.setFocus(false)
  m.osd.hasFocus = false
  m.osd.setFocus(false)
  m.top.setFocus(true)
  if resume
    m.top.control = "resume"
  end if
end sub

' handleChapterListAction: Handles action to show chapter list
'
sub handleChapterListAction()
  m.chapterList.visible = m.osd.showChapterList

  if not m.chapterList.visible then return

  m.chapterMenu.jumpToItem = getCurrentChapterIndex()

  m.osd.hasFocus = false
  m.osd.setFocus(false)
  m.chapterMenu.setFocus(true)
end sub

' getCurrentChapterIndex: Finds current chapter index
'
' @return {integer} indicating index of current chapter within chapter data or 0 if chapter lookup fails
'
function getCurrentChapterIndex() as integer
  if not isValidAndNotEmpty(m.chapters) then return 0

  ' Give a 15 second buffer to compensate for user expectation and roku video position inaccuracy
  ' Web client uses 10 seconds, but this wasn't enough for Roku in testing
  currentPosition = m.top.position + 15
  currentChapter = 0

  for i = m.chapters.count() - 1 to 0 step -1
    if currentPosition >= (m.chapters[i].StartPositionTicks / 10000000#)
      currentChapter = i
      exit for
    end if
  end for

  return currentChapter
end function

' handleVideoPlayPauseAction: Handles action to either play or pause the video content
'
sub handleVideoPlayPauseAction()
  ' If video is paused, resume it
  if m.top.state = "paused"
    handleHideAction(true)
    return
  end if

  ' Pause video
  m.top.control = "pause"
end sub

' handleShowSubtitleMenuAction: Handles action to show subtitle selection menu
'
sub handleShowSubtitleMenuAction()
  m.top.selectSubtitlePressed = true
end sub

' handleShowAudioMenuAction: Handles action to show audio selection menu
'
sub handleShowAudioMenuAction()
  m.top.selectAudioPressed = true
end sub

' handleShowVideoInfoPopupAction: Handles action to show video info popup
'
sub handleShowVideoInfoPopupAction()
  m.top.selectPlaybackInfoPressed = true
end sub

' onOSDAction: Process action events from OSD to their respective handlers
'
sub onOSDAction()
  action = LCase(m.osd.action)

  if action = "hide"
    handleHideAction(false)
    return
  end if

  if action = "play"
    handleHideAction(true)
    return
  end if

  if action = "chapterback" or action = "chapternext"
    handleChapterSkipAction(action)
    return
  end if

  if action = "chapterlist"
    handleChapterListAction()
    return
  end if

  if action = "videoplaypause"
    handleVideoPlayPauseAction()
    return
  end if

  if action = "showsubtitlemenu"
    handleShowSubtitleMenuAction()
    return
  end if

  if action = "showaudiomenu"
    handleShowAudioMenuAction()
    return
  end if

  if action = "showvideoinfopopup"
    handleShowVideoInfoPopupAction()
    return
  end if

  if action = "itemback" or action = "itemnext"
    handleItemSkipAction(action)
    return
  end if
end sub

' Determines if custom subtitles should be used for the current selection
' Custom subtitles should only be used for external subtitles when the user has enabled the setting
function shouldUseCustomSubtitlesForCurrentSelection() as boolean
  ' First check if the user has enabled custom subtitles at all
  if not m.global.user.settings.playbackSubsCustom
    m.log.debug("Custom subtitles disabled by user setting")
    return false
  end if

  ' If no subtitle is currently selected, no need for custom subtitles
  if not isValid(m.top.selectedSubtitle) or m.top.selectedSubtitle = -1
    m.log.debug("No subtitle selected", m.top.selectedSubtitle)
    return false
  end if

  ' Find the selected subtitle in the fullSubtitleData
  selectedSubtitle = invalid
  if isValid(m.top.fullSubtitleData)
    for each subtitle in m.top.fullSubtitleData
      if subtitle.Index = m.top.selectedSubtitle
        selectedSubtitle = subtitle
        exit for
      end if
    end for
  end if

  ' If we found the selected subtitle and it's external, use custom subtitles
  if isValid(selectedSubtitle) and isValid(selectedSubtitle.IsExternal)
    m.log.debug("Subtitle found", selectedSubtitle.IsExternal, selectedSubtitle.Index)
    return selectedSubtitle.IsExternal
  end if

  m.log.debug("Selected subtitle not found in fullSubtitleData or invalid IsExternal flag")
  ' Default to false (use native Roku subtitles)
  return false
end function

' Only setup caption items if captions are allowed
sub onAllowCaptionsChange()
  if not m.top.allowCaptions then return

  m.captionGroup = m.top.findNode("captionGroup")
  m.captionGroup.createchildren(9, "LayoutGroup")
  m.captionTask = createObject("roSGNode", "captionTask")
  m.captionTask.observeField("currentCaption", "updateCaption")
  m.captionTask.observeField("useThis", "checkCaptionMode")
  m.top.observeField("subtitleTrack", "loadCaption")
  m.top.observeField("globalCaptionMode", "toggleCaption")

end sub

' Set caption url to server subtitle track
sub loadCaption()
  m.log.debug("loadCaption() called", m.top.subtitleTrack, m.top.suppressCaptions)
  if m.top.suppressCaptions
    m.log.debug("Setting captionTask.url", m.top.subtitleTrack)
    m.captionTask.url = m.top.subtitleTrack
  end if
end sub

' Toggles visibility of custom subtitles and sets captionTask's player state
sub toggleCaption()
  m.captionTask.playerState = m.top.state + m.top.globalCaptionMode
  if LCase(m.top.globalCaptionMode) = "on"
    m.captionTask.playerState = m.top.state + m.top.globalCaptionMode + "w"
    m.captionGroup.visible = true
  else
    m.captionGroup.visible = false
  end if
end sub

' Removes old subtitle lines and adds new subtitle lines
sub updateCaption()
  m.captionGroup.removeChildrenIndex(m.captionGroup.getChildCount(), 0)
  m.captionGroup.appendChildren(m.captionTask.currentCaption)
end sub

' Event handler for when selectedSubtitle changes
sub onSubtitleChange()
  switchWithoutRefresh = true

  if m.top.SelectedSubtitle <> SubtitleSelection.none
    ' If the global caption mode is off, then Roku can't display the subtitles natively and needs a video stop/start
    if LCase(m.top.globalCaptionMode) <> "on" then switchWithoutRefresh = false
  end if

  ' If previous sustitle was encoded, then we need to a video stop/start to change subtitle content
  if m.top.previousSubtitleWasEncoded then switchWithoutRefresh = false

  ' Update custom subtitle behavior based on new selection
  if m.top.allowCaptions
    shouldUseCustomSubtitles = shouldUseCustomSubtitlesForCurrentSelection()

    m.log.debug("Subtitle changed", shouldUseCustomSubtitles, m.top.suppressCaptions)

    if shouldUseCustomSubtitles <> m.top.suppressCaptions
      ' Custom subtitle mode has changed, update it
      m.log.debug("Changing custom subtitle mode to", shouldUseCustomSubtitles)
      m.top.suppressCaptions = shouldUseCustomSubtitles
      if m.top.suppressCaptions
        ' Turn on globalCaptionMode so toggleCaption() will show the caption group
        m.top.globalCaptionMode = "On"
        ' Manually load the caption since loadCaption() observer may have already fired
        ' with the wrong suppressCaptions value
        if isValid(m.captionTask) and isValid(m.top.subtitleTrack)
          m.captionTask.url = m.top.subtitleTrack
        end if
        toggleCaption()
      else
        ' Explicitly clean up custom subtitle system when switching away from custom subs
        m.captionGroup.visible = false
        if isValid(m.captionTask)
          m.captionTask.url = ""
        end if
      end if
    end if
  end if

  if switchWithoutRefresh then return

  ' Save the current video position
  m.global.queueManager.callFunc("setTopStartingPoint", int(m.top.position) * 10000000&)

  m.top.control = "stop"

  m.LoadMetaDataTask.selectedSubtitleIndex = m.top.SelectedSubtitle
  m.LoadMetaDataTask.selectedAudioStreamIndex = m.top.audioIndex
  m.LoadMetaDataTask.itemId = m.currentItem.id
  m.LoadMetaDataTask.observeField("content", "onVideoContentLoaded")
  m.LoadMetaDataTask.control = "RUN"
end sub

' Event handler for when audioIndex changes
sub onAudioIndexChange()
  ' Skip initial audio index setting
  if m.top.position = 0 then return

  ' Save the current video position
  m.global.queueManager.callFunc("setTopStartingPoint", int(m.top.position) * 10000000&)

  m.top.control = "stop"

  m.LoadMetaDataTask.selectedSubtitleIndex = m.top.SelectedSubtitle
  m.LoadMetaDataTask.selectedAudioStreamIndex = m.top.audioIndex
  m.LoadMetaDataTask.itemId = m.currentItem.id
  m.LoadMetaDataTask.observeField("content", "onVideoContentLoaded")
  m.LoadMetaDataTask.control = "RUN"
end sub

sub onPlaybackErrorDialogClosed(msg)
  sourceNode = msg.getRoSGNode()
  sourceNode.unobserveField("buttonSelected")
  sourceNode.unobserveField("wasClosed")

  m.global.sceneManager.callFunc("popScene")
end sub

sub onPlaybackErrorButtonSelected(msg)
  sourceNode = msg.getRoSGNode()
  sourceNode.close = true
end sub

sub showPlaybackErrorDialog(errorMessage = "" as string)
  dialog = createObject("roSGNode", "Dialog")
  dialog.title = tr("Error During Playback")
  dialog.buttons = [tr("OK")]
  dialog.message = errorMessage
  dialog.observeField("buttonSelected", "onPlaybackErrorButtonSelected")
  dialog.observeField("wasClosed", "onPlaybackErrorDialogClosed")

  m.top.getScene().dialog = dialog
end sub

sub onVideoContentLoaded()
  m.LoadMetaDataTask.unobserveField("content")
  m.LoadMetaDataTask.control = "STOP"

  videoContent = m.LoadMetaDataTask.content
  m.LoadMetaDataTask.content = []

  ' If we have nothing to play, return to previous screen
  if not isValid(videoContent) or not isValid(videoContent[0])
    stopLoadingSpinner()
    showPlaybackErrorDialog(tr("There was an error retrieving the data for this item from the server."))
    return
  end if


  m.top.observeField("state", "onState")

  m.top.content = videoContent[0].content
  m.top.PlaySessionId = videoContent[0].PlaySessionId
  m.top.videoId = videoContent[0].id
  m.top.container = videoContent[0].container
  m.top.mediaSourceId = videoContent[0].mediaSourceId
  m.top.fullSubtitleData = videoContent[0].fullSubtitleData
  m.top.fullAudioData = videoContent[0].fullAudioData
  m.top.audioIndex = videoContent[0].audioIndex
  m.top.transcodeParams = videoContent[0].transcodeparams
  m.chapters = videoContent[0].chapters
  m.top.showID = videoContent[0].showID
  m.top.cachedPlaybackInfo = videoContent[0].playbackInfo

  if isValidAndNotEmpty(videoContent[0].json)
    m.osd.json = formatJson(videoContent[0].json)
  end if

  ' Attempt to add logo to OSD
  if isValidAndNotEmpty(videoContent[0].logoImage)
    m.osd.logoImage = videoContent[0].logoImage
  end if

  populateChapterMenu()

  ' Clean up old carousel cache before loading new video's trickplay data
  ' This handles all video change paths: OSD nav, next episode, queue changes, etc.
  if isValid(m.trickplayCarousel)
    m.trickplayCarousel.callFunc("cleanup")
  end if

  ' Configure trickplay carousel if metadata is available
  if isValidAndNotEmpty(videoContent[0].content.trickplayMetadata)
    m.trickplayCarousel.trickplayConfig = videoContent[0].content.trickplayMetadata
    m.trickplayCarousel.videoDuration = m.top.duration
  else
    m.trickplayCarousel.visible = false
  end if

  ' Allow custom captions for all videos including intro videos
  m.top.allowCaptions = true

  ' Allow default subtitles
  m.top.unobserveField("selectedSubtitle")

  ' Set subtitleTrack property if subs are natively supported by Roku
  selectedSubtitle = invalid
  for each subtitle in m.top.fullSubtitleData
    if subtitle.Index = videoContent[0].selectedSubtitle
      selectedSubtitle = subtitle
      exit for
    end if
  end for

  m.top.selectedSubtitle = videoContent[0].selectedSubtitle

  ' Update custom subtitle behavior based on the selected subtitle
  ' IMPORTANT: This must happen BEFORE setting subtitleTrack to ensure suppressCaptions
  ' is set correctly when the loadCaption() observer fires
  if m.top.allowCaptions
    shouldUseCustomSubtitles = shouldUseCustomSubtitlesForCurrentSelection()
    m.top.suppressCaptions = shouldUseCustomSubtitles
  end if

  if isValid(selectedSubtitle)
    availableSubtitleTrackIndex = availSubtitleTrackIdx(selectedSubtitle.Track.TrackName)
    if availableSubtitleTrackIndex <> -1
      if not selectedSubtitle.IsEncoded
        if selectedSubtitle.IsForced
          ' If IsForced, make sure to remember the Roku global setting so we
          ' can set it back when the video is done playing.
          m.originalClosedCaptionState = m.top.globalCaptionMode
        end if
        m.top.globalCaptionMode = "On"
        m.top.subtitleTrack = m.top.availableSubtitleTracks[availableSubtitleTrackIndex].TrackName
      end if
    end if
  else
    ' No subtitle selected - turn off Roku's native caption system
    ' Only turn off if we're not restoring to a saved state from forced subs
    if not isValid(m.originalClosedCaptionState)
      m.top.globalCaptionMode = "Off"
    end if
  end if

  m.top.observeField("selectedSubtitle", "onSubtitleChange")

  if isValid(m.top.audioIndex)
    ' Convert Jellyfin audio stream index to Roku's 1-indexed audio track position
    m.top.audioTrack = getRokuAudioTrackPosition(m.top.audioIndex, m.top.fullAudioData)
  else
    m.top.audioTrack = "1"
  end if

  ' Make video player visible now that content is loaded and ready to play
  m.top.visible = true

  stopLoadingSpinner()
  m.top.setFocus(true)
  m.top.control = "play"
end sub

' populateChapterMenu: ' Parse chapter data from API and appeand to chapter list menu
'
sub populateChapterMenu()
  ' Clear any existing chapter list data
  m.chapterContent.clear()

  if not isValidAndNotEmpty(m.chapters)
    chapterItem = CreateObject("roSGNode", "ContentNode")
    chapterItem.title = tr("No Chapter Data Found")
    chapterItem.playstart = m.playbackEnum.null
    m.chapterContent.appendChild(chapterItem)
    return
  end if

  for each chapter in m.chapters
    chapterItem = CreateObject("roSGNode", "ContentNode")
    chapterItem.title = chapter.Name
    chapterItem.playstart = chapter.StartPositionTicks / 10000000#
    m.chapterContent.appendChild(chapterItem)
  end for
end sub

' Event handler for when video content field changes
sub onContentChange()
  if not isValid(m.top.content) then return

  m.top.observeField("position", "onPositionChanged")
end sub

sub onNextEpisodeDataLoaded()
  m.checkedForNextEpisode = true

  m.top.observeField("position", "onPositionChanged")

  ' If there is no next episode, disable next episode button
  if m.getNextEpisodeTask.nextEpisodeData.Items.count() <> 2
    m.nextupbuttonseconds = 0
  end if
end sub

'
' Runs Next Episode button animation and sets focus to button
sub showNextEpisodeButton()
  if m.osd.visible then return
  if m.top.content.contenttype <> 4 then return ' only display when content is type "Episode"
  if m.nextupbuttonseconds = 0 then return ' is the button disabled?
  if m.nextEpisodeButton.opacity <> 0 then return

  ' Button always shows for manual next episode selection
  ' Auto-play setting only controls automatic advancement (not button visibility)

  ' Set button text with countdown FIRST, before making visible
  updateCount()

  ' Make visible so button can render with correct text
  m.nextEpisodeButton.visible = true

  ' align button with bottom right edge with 5% padding
  boundingRect = m.notifyButtons.localBoundingRect()

  ' Use boundingRect height if valid and button has rendered with text (height > 35)
  ' Height < 35 means button hasn't finished rendering with countdown text yet
  if boundingRect.height <> invalid and boundingRect.height > 35
    buttonHeight = boundingRect.height
  else
    buttonHeight = 83 ' default height
  end if

  m.notifyButtons.translation = [
    1920 - (1920 * 0.05),
    1080 - (1080 * 0.05) - buttonHeight
  ]

  ' Start opacity animation
  m.showNextEpisodeButtonAnimation.control = "start"
  m.nextEpisodeButton.setFocus(true)
end sub

'
'Update count down text
sub updateCount()
  nextEpisodeCountdown = Int(m.top.duration - m.top.position)
  if nextEpisodeCountdown < 0
    nextEpisodeCountdown = 0
  end if
  m.nextEpisodeButton.text = tr("Next Episode") + " " + nextEpisodeCountdown.toStr().trim()
end sub

'
' Runs hide Next Episode button animation and sets focus back to video
sub hideNextEpisodeButton()
  m.hideNextEpisodeButtonAnimation.control = "start"
  m.nextEpisodeButton.setFocus(false)
  m.top.setFocus(true)
end sub

' Checks if we need to display the Next Episode button
sub checkTimeToDisplayNextEpisode()
  if m.top.content.contenttype <> 4 then return ' only display when content is type "Episode"
  if m.nextupbuttonseconds = 0 then return ' is the button disabled?

  ' Don't show Next Episode button if trickPlayBar is visible
  if m.top.trickPlayBar.visible then return

  if isValid(m.top.duration) and isValid(m.top.position)
    nextEpisodeCountdown = Int(m.top.duration - m.top.position)

    if nextEpisodeCountdown < 0 and m.nextEpisodeButton.opacity = 0.9
      hideNextEpisodeButton()
      return
    else if nextEpisodeCountdown > 1 and int(m.top.position) >= (m.top.duration - m.nextupbuttonseconds - 1)
      if m.nextEpisodeButton.opacity = 0
        ' First time showing - showNextEpisodeButton will set the text
        showNextEpisodeButton()
      else
        ' Button already showing - just update the countdown text
        updateCount()
      end if
      return
    end if
  end if

  ' If button is showing but shouldn't be, hide it
  if m.nextEpisodeButton.visible or m.nextEpisodeButton.hasFocus()
    m.nextEpisodeButton.visible = false
    m.nextEpisodeButton.setFocus(false)
  end if
end sub

' When Video Player state changes
sub onPositionChanged()
  ' Pass video position data into OSD
  if m.top.duration = 0
    m.osd.progressPercentage = 0
  else
    m.osd.progressPercentage = m.top.position / m.top.duration
  end if
  m.osd.positionTime = m.top.position
  m.osd.remainingPositionTime = m.top.duration - m.top.position

  if isValid(m.captionTask)
    m.captionTask.currentPos = Int(m.top.position * 1000)
  end if

  ' Update trickplay carousel's playback position for proactive tile caching
  ' This runs even when carousel is not visible to keep cache warm
  if isValid(m.trickplayCarousel)
    m.trickplayCarousel.playbackPosition = m.top.position
  end if

  ' Check if dialog is open
  m.dialog = m.top.getScene().findNode("dialogBackground")
  if not isValid(m.dialog)
    ' Do not show Next Episode button for intro videos
    if not m.LoadMetaDataTask.isIntro
      checkTimeToDisplayNextEpisode()
    end if
  end if

  ' Tie carousel visibility to trickPlayBar (only when OSD is not visible)
  ' BUT not if we've explicitly hidden it during seek confirmation
  if isValid(m.trickplayCarousel) and not m.carouselHiddenForSeek
    trickPlayBarVisible = m.top.trickPlayBar.visible and not m.osd.visible
    m.trickplayCarousel.visible = trickPlayBarVisible

    ' Reset seek tracking when trickPlayBar closes (user confirmed or cancelled seek)
    if not trickPlayBarVisible
      m.isTrackingSeek = false
      m.carouselHiddenForSeek = false
      m.lastSentThumbnailIndex = -1 ' Reset so next scrub session sends initial position
    end if
  end if

  ' Update trickplay carousel position during normal playback only
  ' When trickPlayBar is visible, onTrickPlayBarTextChange is the authoritative source
  if isValid(m.trickplayCarousel) and m.trickplayCarousel.visible and not m.top.trickPlayBar.visible
    updateTrickplayCarousel(m.top.position)
  end if
end sub

' Updates trickplay carousel with index calculated from video position
' Snaps to thumbnail boundaries for cleaner UX
' @param {Float} position - Video position in seconds
sub updateTrickplayCarousel(position as float)
  if not isValid(m.trickplayCarousel) then return
  if not isValidAndNotEmpty(m.trickplayCarousel.trickplayConfig) then return

  interval = m.trickplayCarousel.trickplayConfig.interval

  ' Calculate thumbnail index from position
  thumbnailIndex = trickplay.calculateThumbnailIndex(position, interval)

  ' Skip if same index as last sent - prevents double-rendering at tile boundaries
  ' when both onPositionChanged and onTrickPlayBarTextChange fire with similar positions
  if thumbnailIndex = m.lastSentThumbnailIndex then return
  m.lastSentThumbnailIndex = thumbnailIndex

  ' Update carousel with index (triggers shifting logic)
  m.trickplayCarousel.thumbnailIndex = thumbnailIndex
end sub

' Called when Roku's trickPlayBar position text changes
' Parses the time string to get seek position and syncs our carousel
' This ensures carousel stays in sync with Roku's authoritative seek position
sub onTrickPlayBarTextChange()
  if not m.top.trickPlayBar.visible then return
  if not isValid(m.trickPlayBarPositionText) then return

  timeText = m.trickPlayBarPositionText.text
  if not isValidAndNotEmpty(timeText) then return

  ' Parse time string "53:50" (MM:SS) or "1:23:45" (H:MM:SS) to seconds
  seekPosition = timeText.split(":")
  seekTime = 0

  if seekPosition.count() = 3
    ' H:MM:SS format
    seekTime = seekPosition[0].toInt() * 3600 ' hours
    seekTime = seekTime + seekPosition[1].toInt() * 60 ' minutes
    seekTime = seekTime + seekPosition[2].toInt() ' seconds
  else if seekPosition.count() = 2
    ' MM:SS format
    seekTime = seekPosition[0].toInt() * 60 ' minutes
    seekTime = seekTime + seekPosition[1].toInt() ' seconds
  else
    ' Unexpected format - use current position as fallback
    seekTime = m.top.position
  end if

  m.log.debug("TrickPlayBar text changed", timeText, "parsed to", seekTime, "seconds")

  ' Sync carousel with Roku's authoritative seek position
  m.isTrackingSeek = true

  ' Update carousel to match
  if isValid(m.trickplayCarousel) and m.trickplayCarousel.visible
    updateTrickplayCarousel(seekTime)
  end if
end sub

'
' When Video Player state changes
sub onState()
  m.log.debug("start onState", m.top.state)
  if isValid(m.captionTask)
    m.captionTask.playerState = m.top.state + m.top.globalCaptionMode
  end if

  ' Pass video state into OSD
  m.osd.playbackState = m.top.state

  if m.top.state = "buffering"
    ' When buffering, start timer to monitor buffering process
    if isValid(m.bufferCheckTimer)
      m.bufferCheckTimer.control = "start"
      m.bufferCheckTimer.ObserveField("fire", "bufferCheck")
    end if
  else if m.top.state = "error"
    m.log.error(m.top.errorCode, m.top.errorMsg, m.top.errorStr, m.playReported, m.top.transcodeAvailable)

    print m.top.errorInfo

    if not m.playReported and m.top.transcodeAvailable
      m.log.info("retrying with transcoding", m.currentItem.id, m.top.SelectedSubtitle, m.top.audioIndex)
      m.top.retryWithTranscoding = true ' If playback was not reported, retry with transcoding
    else
      ' If an error was encountered, Display dialog
      m.top.unobserveField("state")
      m.playbackTimer.control = "stop"
      showPlaybackErrorDialog(tr("Error During Playback"))
    end if
  else if m.top.state = "playing"
    ' Check if next episode is available
    if isValid(m.top.showID)
      if m.top.showID <> "" and not m.checkedForNextEpisode and m.top.content.contenttype = 4
        m.getNextEpisodeTask.showID = m.top.showID
        m.getNextEpisodeTask.videoID = m.top.id
        m.getNextEpisodeTask.control = "RUN"
      end if
    end if

    if m.playReported = false
      ReportPlayback("start")
      m.playReported = true
    else
      ReportPlayback()
    end if
    m.playbackTimer.control = "start"
  else if m.top.state = "paused"
    m.playbackTimer.control = "stop"
    ReportPlayback()
  else if m.top.state = "stopped"
    m.playbackTimer.control = "stop"
    m.playbackTimer.unobserveField("fire")
    ReportPlayback("stop")
    m.playReported = false
    ' Cleanup trickplay carousel
    if isValid(m.trickplayCarousel)
      m.trickplayCarousel.visible = false
      m.trickplayCarousel.callFunc("cleanup")
    end if
  else if m.top.state = "finished"
    m.playbackTimer.control = "stop"
    m.playbackTimer.unobserveField("fire")
    ReportPlayback("finished")
    ' Cleanup trickplay carousel
    if isValid(m.trickplayCarousel)
      m.trickplayCarousel.visible = false
      m.trickplayCarousel.callFunc("cleanup")
    end if
  else
    m.log.warning("Unhandled state", m.top.state, m.playReported, m.playFinished)
  end if
  m.log.debug("end onState", m.top.state)
end sub

'
' Report playback to server
sub ReportPlayback(state = "update" as string)
  if not isValid(m.top.position) then return

  m.log.debug("start ReportPlayback", state, int(m.top.position))

  params = {
    "ItemId": m.top.id,
    "PlaySessionId": m.top.PlaySessionId,
    "PositionTicks": int(m.top.position) * 10000000&, 'Ensure a LongInteger is used
    "IsPaused": (m.top.state = "paused")
  }
  if isValid(m.top.content) and isValid(m.top.content.live) and m.top.content.live
    params.append({
      "MediaSourceId": m.top.transcodeParams.MediaSourceId,
      "LiveStreamId": m.top.transcodeParams.LiveStreamId
    })
    m.bufferCheckTimer.duration = 30
  end if

  if (state = "stop" or state = "finished") and isValid(m.originalClosedCaptionState)
    m.log.debug("ReportPlayback setting", m.top.globalCaptionMode, "back to", m.originalClosedCaptionState)
    m.top.globalCaptionMode = m.originalClosedCaptionState
    m.originalClosedCaptionState = invalid
  end if

  ' Report playstate via worker task
  playstateTask = m.global.playstateTask
  playstateTask.setFields({ status: state, params: params })
  playstateTask.control = "RUN"

  m.log.debug("end ReportPlayback", state, int(m.top.position))
end sub

'
' Check the the buffering has not hung
sub bufferCheck()

  if m.top.state <> "buffering"
    ' If video is not buffering, stop timer
    m.bufferCheckTimer.control = "stop"
    m.bufferCheckTimer.unobserveField("fire")
    return
  end if
  if isValid(m.top.bufferingStatus)

    ' Check that the buffering percentage is increasing
    if m.top.bufferingStatus["percentage"] > m.bufferPercentage
      m.bufferPercentage = m.top.bufferingStatus["percentage"]
    else if m.top.content.live = true
      m.top.callFunc("refresh")
    else
      ' If buffering has stopped Display dialog
      showPlaybackErrorDialog(tr("There was an error retrieving the data for this item from the server."))

      ' Stop playback and exit player
      m.top.control = "stop"
    end if
  end if

end sub

' stateAllowsOSD: Check if current video state allows showing the OSD
'
' @return {boolean} indicating if video state allows the OSD to show
function stateAllowsOSD() as boolean
  validStates = ["playing", "paused", "stopped"]
  return inArray(validStates, m.top.state)
end function


' availSubtitleTrackIdx: Returns Roku's index for requested subtitle track
'
' @param {string} tracknameToFind - TrackName for subtitle we're looking to match
' @return {integer} indicating Roku's index for requested subtitle track. Returns SubtitleSelection.none if not found
function availSubtitleTrackIdx(tracknameToFind as string) as integer
  idx = 0
  for each availTrack in m.top.availableSubtitleTracks
    ' The TrackName must contain the URL we supplied originally, though
    ' Roku mangles the name a bit, so we check if the URL is a substring, rather
    ' than strict equality
    if Instr(1, availTrack.TrackName, tracknameToFind)
      return idx
    end if
    idx = idx + 1
  end for
  return SubtitleSelection.none
end function

function onKeyEvent(key as string, press as boolean) as boolean

  ' Keypress handler while user is inside the chapter menu
  if m.chapterMenu.hasFocus()
    if not press then return false

    if key = "OK"
      focusedChapter = m.chapterMenu.itemFocused
      selectedChapter = m.chapterMenu.content.getChild(focusedChapter)
      seekTime = selectedChapter.playstart

      ' Don't seek if user clicked on No Chapter Data
      if seekTime = m.playbackEnum.null then return true

      m.top.seek = seekTime
      return true
    end if

    if key = "back" or key = "replay"
      m.chapterList.visible = false
      m.osd.showChapterList = false
      m.chapterMenu.setFocus(false)
      m.osd.hasFocus = true
      m.osd.setFocus(true)
      return true
    end if

    if key = "play"
      handleVideoPlayPauseAction()
    end if

    return true
  end if

  if key = "OK" and m.nextEpisodeButton.hasfocus() and not m.top.trickPlayBar.visible
    m.top.control = "stop"
    m.top.state = "finished"
    hideNextEpisodeButton()
    return true
  else
    'Hide Next Episode Button
    if m.nextEpisodeButton.opacity > 0 or m.nextEpisodeButton.hasFocus()
      m.nextEpisodeButton.opacity = 0
      m.nextEpisodeButton.setFocus(false)
      m.top.setFocus(true)
    end if
  end if

  if not press then return false

  if key = "down" and not m.top.trickPlayBar.visible
    ' Don't allow user to open menu prior to video loading
    if not stateAllowsOSD() then return true

    m.osd.visible = true
    m.osd.hasFocus = true
    m.osd.setFocus(true)
    return true

  else if key = "up" and not m.top.trickPlayBar.visible
    ' Don't allow user to open menu prior to video loading
    if not stateAllowsOSD() then return true

    m.osd.visible = true
    m.osd.hasFocus = true
    m.osd.setFocus(true)
    return true

  else if key = "OK" and not m.top.trickPlayBar.visible
    ' Don't allow user to open menu prior to video loading
    if not stateAllowsOSD() then return true

    ' Show OSD, but don't pause video
    m.osd.visible = true
    m.osd.hasFocus = true
    m.osd.setFocus(true)
    return true
  end if

  ' Disable OSD for intro videos
  if key = "play" and not m.top.trickPlayBar.visible

    ' Don't allow user to open menu prior to video loading
    if not stateAllowsOSD() then return true

    ' If video is paused, resume it and don't show OSD
    if m.top.state = "paused"
      m.top.control = "resume"
      return true
    end if

    ' Pause video and show OSD
    m.top.control = "pause"
    m.osd.playbackState = "paused"
    m.osd.visible = true
    m.osd.hasFocus = true
    m.osd.setFocus(true)
    return true
  end if

  if key = "back"
    m.top.control = "stop"
  end if

  ' Handle OK/Play key during seek - hide carousel and let Roku seek to its position
  ' Since we're now synced to Roku's position via the trickPlayBar text observer,
  ' we don't need to do our own seek - Roku's native seek will match our displayed thumbnail
  if (key = "OK" or key = "play") and m.top.trickPlayBar.visible

    m.isTrackingSeek = false
    if isValid(m.trickplayCarousel)
      m.trickplayCarousel.visible = false
      m.carouselHiddenForSeek = true ' Prevent auto-show until trickPlayBar closes
    end if
    ' Return false to let Roku handle the seek and close the trickPlayBar
    return false
  end if

  ' Handle left/right/FF/RW keys - show carousel, observer syncs position from trickPlayBar text
  if not m.osd.visible and (key = "left" or key = "right" or key = "fastforward" or key = "rewind")
    if isValid(m.trickplayCarousel)
      m.trickplayCarousel.visible = true
    end if
    return false
  end if

  return false
end function
