namespace tests

  @suite("misc.bs - Audio Stream Functions")
  class MiscAudioStreamsTests extends tests.BaseTestSuite

    protected override function setup()
      super.setup()
      ' Setup mock stream data with various configurations
      m.setupMockStreamData()
    end function

    ' Helper function to create mock stream data
    sub setupMockStreamData()
      ' Standard stream configuration: video at 0, audio at 1 and 2
      m.standardStreams = [
        { Type: "Video", index: 0, Codec: "h264" },
        { Type: "Audio", index: 1, Language: "eng", Codec: "aac" },
        { Type: "Audio", index: 2, Language: "jpn", Codec: "aac" }
      ]

      ' Non-contiguous indexes (e.g., video stream removed)
      m.nonContiguousStreams = [
        { Type: "Audio", index: 5, Language: "eng", Codec: "aac" },
        { Type: "Audio", index: 10, Language: "jpn", Codec: "aac" },
        { Type: "Subtitle", index: 15, Language: "eng" }
      ]

      ' Audio first configuration
      m.audioFirstStreams = [
        { Type: "Audio", index: 0, Language: "eng", Codec: "aac" },
        { Type: "Video", index: 1, Codec: "h264" },
        { Type: "Audio", index: 2, Language: "spa", Codec: "aac" }
      ]

      ' Only video streams (no audio)
      m.noAudioStreams = [
        { Type: "Video", index: 0, Codec: "h264" },
        { Type: "Subtitle", index: 1, Language: "eng" }
      ]

      ' Streams with missing index fields
      m.missingIndexStreams = [
        { Type: "Video", Codec: "h264" },
        { Type: "Audio", index: 5, Language: "eng", Codec: "aac" },
        { Type: "Audio", Language: "jpn", Codec: "aac" }
      ]

      ' Multiple languages for preference testing
      m.multiLanguageStreams = [
        { Type: "Video", index: 0, Codec: "h264" },
        { Type: "Audio", index: 1, Language: "jpn", Codec: "aac" },
        { Type: "Audio", index: 2, Language: "eng", Codec: "aac" },
        { Type: "Audio", index: 3, Language: "spa", Codec: "aac" }
      ]
    end sub

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    @describe("getFirstAudioStreamIndex()")
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    @it("returns 0 when streams is invalid")
    function _()
      result = getFirstAudioStreamIndex(invalid)
      m.assertEqual(result, 0)
    end function

    @it("returns 0 when streams is empty array")
    function _()
      result = getFirstAudioStreamIndex([])
      m.assertEqual(result, 0)
    end function

    @it("returns 0 when no audio streams exist")
    function _()
      result = getFirstAudioStreamIndex(m.noAudioStreams)
      m.assertEqual(result, 0)
    end function

    @it("returns first audio stream index when audio is not at position 0")
    function _()
      result = getFirstAudioStreamIndex(m.standardStreams)
      m.assertEqual(result, 1)
    end function

    @it("returns first audio stream index when audio is at position 0")
    function _()
      result = getFirstAudioStreamIndex(m.audioFirstStreams)
      m.assertEqual(result, 0)
    end function

    @it("returns correct Jellyfin index with non-contiguous indexes")
    function _()
      result = getFirstAudioStreamIndex(m.nonContiguousStreams)
      m.assertEqual(result, 5)
    end function

    @it("skips audio streams with missing index field")
    function _()
      ' Should skip the first audio stream (no index) and return the second audio stream's index
      result = getFirstAudioStreamIndex(m.missingIndexStreams)
      m.assertEqual(result, 5)
    end function

    @it("returns 0 when all audio streams have missing index field")
    function _()
      streams = [
        { Type: "Video", index: 0, Codec: "h264" },
        { Type: "Audio", Language: "eng", Codec: "aac" },
        { Type: "Audio", Language: "jpn", Codec: "aac" }
      ]
      result = getFirstAudioStreamIndex(streams)
      m.assertEqual(result, 0)
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    @describe("getRokuAudioTrackPosition()")
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    @it("returns '1' when audioStreamsArray is invalid")
    function _()
      result = getRokuAudioTrackPosition(5, invalid)
      m.assertEqual(result, "1")
    end function

    @it("returns '1' when audioStreamsArray is empty")
    function _()
      result = getRokuAudioTrackPosition(5, [])
      m.assertEqual(result, "1")
    end function

    @it("returns '1' when Jellyfin index not found in array")
    function _()
      audioStreams = [
        { index: 1, Language: "eng" },
        { index: 2, Language: "jpn" }
      ]
      result = getRokuAudioTrackPosition(5, audioStreams)
      m.assertEqual(result, "1")
    end function

    @it("converts array position 0 to Roku track '1'")
    function _()
      audioStreams = [
        { index: 5, Language: "eng" },
        { index: 10, Language: "jpn" }
      ]
      result = getRokuAudioTrackPosition(5, audioStreams)
      m.assertEqual(result, "1")
    end function

    @it("converts array position 1 to Roku track '2'")
    function _()
      audioStreams = [
        { index: 5, Language: "eng" },
        { index: 10, Language: "jpn" }
      ]
      result = getRokuAudioTrackPosition(10, audioStreams)
      m.assertEqual(result, "2")
    end function

    @it("converts array position 2 to Roku track '3'")
    function _()
      audioStreams = [
        { index: 5, Language: "eng" },
        { index: 10, Language: "jpn" },
        { index: 15, Language: "spa" }
      ]
      result = getRokuAudioTrackPosition(15, audioStreams)
      m.assertEqual(result, "3")
    end function

    @it("handles non-contiguous Jellyfin indexes correctly")
    function _()
      audioStreams = [
        { index: 100, Language: "eng" },
        { index: 200, Language: "jpn" },
        { index: 300, Language: "spa" }
      ]
      result = getRokuAudioTrackPosition(200, audioStreams)
      m.assertEqual(result, "2")
    end function

    @it("skips streams with missing index field")
    function _()
      audioStreams = [
        { Language: "eng" },
        { index: 5, Language: "jpn" },
        { index: 10, Language: "spa" }
      ]
      result = getRokuAudioTrackPosition(10, audioStreams)
      m.assertEqual(result, "3")
    end function

    @it("returns '1' when all streams have missing index field")
    function _()
      audioStreams = [
        { Language: "eng" },
        { Language: "jpn" }
      ]
      result = getRokuAudioTrackPosition(5, audioStreams)
      m.assertEqual(result, "1")
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    @describe("findPreferredAudioStreamIndex()")
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    @it("returns 0 when streams is invalid")
    function _()
      result = findPreferredAudioStreamIndex(invalid, false, "eng")
      m.assertEqual(result, 0)
    end function

    @it("returns 0 when streams is empty array")
    function _()
      result = findPreferredAudioStreamIndex([], false, "eng")
      m.assertEqual(result, 0)
    end function

    @it("returns first audio stream index when playDefault is true")
    function _()
      result = findPreferredAudioStreamIndex(m.multiLanguageStreams, true, "eng")
      ' Should return index of first audio stream (Japanese at index 1)
      m.assertEqual(result, 1)
    end function

    @it("returns preferred language audio stream index when found")
    function _()
      result = findPreferredAudioStreamIndex(m.multiLanguageStreams, false, "eng")
      ' Should return English audio stream at index 2
      m.assertEqual(result, 2)
    end function

    @it("returns first audio stream index when preferred language not found")
    function _()
      result = findPreferredAudioStreamIndex(m.multiLanguageStreams, false, "fre")
      ' Should fallback to first audio stream (Japanese at index 1)
      m.assertEqual(result, 1)
    end function

    @it("handles case-insensitive language matching")
    function _()
      streamsWithUpperCase = [
        { Type: "Audio", index: 1, Language: "eng", Codec: "aac" },
        { Type: "Audio", index: 2, Language: "jpn", Codec: "aac" }
      ]
      result = findPreferredAudioStreamIndex(streamsWithUpperCase, false, "ENG")
      m.assertEqual(result, 1)
    end function

    @it("returns correct Jellyfin index with non-contiguous indexes")
    function _()
      result = findPreferredAudioStreamIndex(m.nonContiguousStreams, false, "eng")
      ' Should return English audio stream at index 5
      m.assertEqual(result, 5)
    end function

    @it("skips audio streams with missing index field when searching for preference")
    function _()
      streams = [
        { Type: "Audio", Language: "eng", Codec: "aac" },
        { Type: "Audio", index: 10, Language: "eng", Codec: "aac" },
        { Type: "Audio", index: 15, Language: "jpn", Codec: "aac" }
      ]
      result = findPreferredAudioStreamIndex(streams, false, "eng")
      ' Should skip first English stream (no index) and return second at index 10
      m.assertEqual(result, 10)
    end function

    @it("returns 0 when no audio streams have valid index field")
    function _()
      streams = [
        { Type: "Audio", Language: "eng", Codec: "aac" },
        { Type: "Audio", Language: "jpn", Codec: "aac" }
      ]
      result = findPreferredAudioStreamIndex(streams, false, "eng")
      m.assertEqual(result, 0)
    end function

    @it("returns first audio stream when preferredLanguage is invalid")
    function _()
      result = findPreferredAudioStreamIndex(m.standardStreams, false, invalid)
      ' Should return first audio stream at index 1
      m.assertEqual(result, 1)
    end function

    @it("returns first audio stream when preferredLanguage is empty string")
    function _()
      result = findPreferredAudioStreamIndex(m.standardStreams, false, "")
      ' Should return first audio stream at index 1
      m.assertEqual(result, 1)
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    @describe("findPreferredAudioStreamIndex() - Parameterized Language Tests")
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    @it("finds correct audio stream for various language preferences")
    @params("jpn", 1)
    @params("eng", 2)
    @params("spa", 3)
    function _(language, expectedIndex)
      result = findPreferredAudioStreamIndex(m.multiLanguageStreams, false, language)
      m.assertEqual(result, expectedIndex)
    end function

  end class

end namespace
