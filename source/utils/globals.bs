' Low memory device model prefixes (512MB RAM, ~50MB texture memory)
' These devices cannot load large textures (e.g., default trickplay 10x10 320 tiles) into memory
' See: https://github.com/cewert/jellyrock/issues/299
const LOW_MEMORY_DEVICE_PREFIXES = [
  ' Current Models
  "3840", ' Roku Streaming Stick (Lakeport) - 512MB - 720p
  "K8PX", ' Projector (Avery) - 512MB - 720p
  "8000", ' Roku TV (Midland/El Paso) - 512MB - 720p
  "H000", ' 2K Roku TV (Miami) - 512MB - 720p
  "T100", ' Roku TV (Alpine) - 512MB - 720p
  ' Updatable Models
  "3960", ' Roku Express (Rockett) - 512MB - 720p
  "3931", ' Roku Express+ (Nemo) - 512MB - 720p
  "3600", ' Roku Streaming Stick (Briscoe) - 512MB - 720p
  "3700", ' Roku Express (Littlefield) - 512MB - 720p
  "3710", ' Roku Express+ (Littlefield) - 512MB - 720p
  "3800", ' Roku Streaming Stick (Amarillo) - 512MB - 720p
  "4200", ' Roku 3 (Austin) - 512MB - 720p
  "4210", ' Roku 2 (Mustang) - 512MB - 720p
  "4230", ' Roku 3 (Mustang) - 512MB - 720p
  "5000", ' Roku TV (Liberty) - 512MB - 720p
  "D000", ' Roku TV (Roma) - 512MB - 720p
  "K000", ' Roku TV (Roxton) - 512MB - 720p
  ' Legacy Models
  "2700", ' Roku LT (Tyler) - 512MB - supports OS 11
  "2710", ' Roku 1, Roku SE (Tyler) - 512MB - supports OS 11
  "2720", ' Roku 2 (Tyler) - 512MB - supports OS 11
  "3500" ' Roku Streaming Stick (Sugarland) - 512MB - supports OS 11
]

' Check if device model matches a low memory device (512MB RAM)
' @param {String} deviceModel - The device model string from roDeviceInfo.GetModel()
' @return {Boolean} - true if device is a low memory device
function checkIsLowMemoryDevice(deviceModel as string) as boolean
  if deviceModel = "" then return false

  for each prefix in LOW_MEMORY_DEVICE_PREFIXES
    if deviceModel.left(len(prefix)) = prefix
      return true
    end if
  end for

  return false
end function

' Set all global variables that don't require an roSGNode
sub setGlobals()
  ' Initialize session content nodes
  serverNode = CreateObject("roSGNode", "JellyfinServer")
  userNode = CreateObject("roSGNode", "JellyfinUser")

  ' Initialize nested user nodes
  settingsNode = CreateObject("roSGNode", "JellyfinUserSettings")
  configNode = CreateObject("roSGNode", "JellyfinUserConfiguration")
  policyNode = CreateObject("roSGNode", "JellyfinUserPolicy")

  userNode.settings = settingsNode
  userNode.config = configNode
  userNode.policy = policyNode

  m.global.addFields({
    appLoaded: false,
    server: serverNode,
    user: userNode
  })
  ' Save Constants
  setConstants()
  ' Save information from roAppInfo to m.global.app
  SaveAppToGlobal()
  ' Save information from roDeviceInfo to m.global.device
  SaveDeviceToGlobal()
end sub

' Set all global variables that require an roSGNode
' NOTE: roSGNodes must be created after m.screen is shown
sub setGlobalNodes()
  playstateTask = CreateObject("roSGNode", "PlaystateTask")
  playstateTask.id = "playstateTask"
  m.global.addFields({ playstateTask: playstateTask })

  sceneManager = CreateObject("roSGNode", "SceneManager")
  sceneManager.observeField("dataReturned", m.port)
  sceneManager.observeField("reloadHomeRequested", m.port)
  m.global.addFields({ sceneManager: sceneManager })

  m.global.addFields({ queueManager: CreateObject("roSGNode", "QueueManager") })
  m.global.addFields({ audioPlayer: CreateObject("roSGNode", "AudioPlayer") })
end sub

' Save Constants
sub setConstants()
  ' Create Constants content node
  constantsNode = CreateObject("roSGNode", "Constants")

  m.global.addFields({ constants: constantsNode })

  ' Load theme color defaults from settings.json (single source of truth)
  loadThemeColorDefaults()
end sub

' ============================================
' THEME COLOR FUNCTIONS
' ============================================

' Load theme color defaults from settings.json to Constants
' This ensures settings.json is the single source of truth for default colors
sub loadThemeColorDefaults()
  constants = m.global.constants
  if not isValid(constants) then return

  configTree = GetConfigTree()
  if not isValid(configTree) then return

  ' Map setting names to constant field names
  colorMap = {
    "uiThemeColorPrimary": "colorPrimary",
    "uiThemeColorSecondary": "colorSecondary",
    "uiThemeColorBackgroundPrimary": "colorBackgroundPrimary",
    "uiThemeColorBackgroundSecondary": "colorBackgroundSecondary",
    "uiThemeColorTextPrimary": "colorTextPrimary",
    "uiThemeColorTextSecondary": "colorTextSecondary",
    "uiThemeColorTextDisabled": "colorTextDisabled"
  }

  for each settingName in colorMap
    constantName = colorMap[settingName]
    settingDef = findConfigTreeKey(settingName, configTree)

    if isValid(settingDef) and isValid(settingDef.default)
      ' Apply default from settings.json with "0x" prefix
      constants[constantName] = "0x" + UCase(settingDef.default)
    end if
  end for
end sub

' Apply theme color overrides from user settings to Constants
' Only applies valid 6-character hex colors; invalid values are ignored (keeps default)
sub applyThemeColorOverrides(userSettings as object)
  if not isValid(userSettings) then return

  constants = m.global.constants
  if not isValid(constants) then return

  ' Map setting names to constant field names
  colorMap = {
    "uiThemeColorPrimary": "colorPrimary",
    "uiThemeColorSecondary": "colorSecondary",
    "uiThemeColorBackgroundPrimary": "colorBackgroundPrimary",
    "uiThemeColorBackgroundSecondary": "colorBackgroundSecondary",
    "uiThemeColorTextPrimary": "colorTextPrimary",
    "uiThemeColorTextSecondary": "colorTextSecondary",
    "uiThemeColorTextDisabled": "colorTextDisabled"
  }

  for each settingName in colorMap
    constantName = colorMap[settingName]
    userValue = userSettings[settingName]

    ' Only apply if value exists and is a valid 6-char hex color
    if isValidHexColor(userValue)
      constants[constantName] = "0x" + UCase(userValue)
    end if
  end for
end sub

' Reset theme colors to defaults from settings.json
sub resetThemeColors()
  loadThemeColorDefaults()
end sub

' Validate hex color input (exactly 6 hex characters: 0-9, A-F)
' Returns false for empty, invalid, or wrong-length strings
function isValidHexColor(input as dynamic) as boolean
  if not isValid(input) then return false
  if type(input) <> "roString" and type(input) <> "String" then return false
  if input.Len() <> 6 then return false

  validChars = "0123456789ABCDEF"
  for i = 0 to 5
    char = UCase(input.Mid(i, 1))
    if Instr(1, validChars, char) = 0
      return false
    end if
  end for

  return true
end function

' Save information from roAppInfo to m.global.app
sub SaveAppToGlobal()
  appInfo = CreateObject("roAppInfo")
  lastRunVersion = get_setting("LastRunVersion")

  ' Create and populate AppInfo content node
  appNode = CreateObject("roSGNode", "AppInfo")
  appNode.appId = appInfo.GetID()
  appNode.isDev = appInfo.IsDev()
  appNode.version = appInfo.GetVersion()
  appNode.lastRunVersion = lastRunVersion

  m.global.addFields({ app: appNode })
end sub

' Save information from roDeviceInfo to m.global.device
sub SaveDeviceToGlobal()
  deviceInfo = CreateObject("roDeviceInfo")

  ' remove special characters
  regex = CreateObject("roRegex", "[^a-zA-Z0-9\ \-\_]", "")
  filteredFriendly = regex.ReplaceAll(deviceInfo.getFriendlyName(), "")
  ' parse out serial
  displayName = deviceInfo.getModelDisplayName()
  deviceSerial = Mid(filteredFriendly, len(displayName) + 4)
  ' determine max playback resolution
  ' https://developer.roku.com/en-ca/docs/references/brightscript/interfaces/ifdeviceinfo.md#getvideomode-as-string
  videoMode = deviceInfo.GetVideoMode()
  iPos = Instr(1, videoMode, "i")
  pPos = Instr(1, videoMode, "p")
  videoHeight = invalid
  videoWidth = invalid
  refreshRate = "0"
  bitDepth = 8
  extraData = invalid
  heightToWidth = {
    "480": "720",
    "576": "720",
    "720": "1280",
    "1080": "1920",
    "2160": "3840",
    "4320": "7680"

  }
  if iPos > 0 and pPos = 0
    ' videMode = 000i
    videoHeight = mid(videoMode, 1, iPos - 1)
    ' save refresh rate
    if Len(videoMode) > iPos
      refreshRate = mid(videoMode, iPos + 1, 2)
    end if
    ' save whats left of string
    if Len(videoMode) > iPos + 2
      extraData = mid(videoMode, iPos + 3)
    end if
  else if iPos = 0 and pPos > 0
    ' videMode = 000p
    videoHeight = mid(videoMode, 1, pPos - 1)
    ' save refresh rate
    if Len(videoMode) > pPos
      refreshRate = mid(videoMode, pPos + 1, 2)
    end if
    ' save whats left of string
    if Len(videoMode) > pPos + 2
      extraData = mid(videoMode, pPos + 3)
    end if
  else
    'i and p not present in videoMode
    print "ERROR parsing deviceInfo.GetVideoMode()"
  end if
  videoWidth = heightToWidth[videoHeight]
  if isValid(extraData) and extraData = "b10" then bitDepth = 10
  if videoHeight = "4320" then bitDepth = 12

  ' Create and populate DeviceInfo content node
  deviceNode = CreateObject("roSGNode", "DeviceInfo")
  deviceNode.id = deviceInfo.getChannelClientID()
  deviceNode.uuid = deviceInfo.GetRandomUUID()
  deviceNode.name = displayName
  deviceNode.friendlyName = filteredFriendly
  deviceNode.serverDeviceName = deviceInfo.getChannelClientID()
  deviceNode.model = deviceInfo.GetModel()
  deviceNode.modelType = deviceInfo.GetModelType()
  deviceNode.modelDetails = deviceInfo.GetModelDetails()
  deviceNode.serial = deviceSerial
  deviceNode.osVersion = deviceInfo.GetOSVersion()
  deviceNode.locale = deviceInfo.GetCurrentLocale()
  deviceNode.clockFormat = deviceInfo.GetClockFormat()
  deviceNode.isAudioGuideEnabled = deviceInfo.IsAudioGuideEnabled()
  deviceNode.hasVoiceRemote = deviceInfo.HasFeature("voice_remote")
  deviceNode.displayType = deviceInfo.GetDisplayType()
  deviceNode.displayMode = deviceInfo.GetDisplayMode()
  uiRes = deviceInfo.GetUIResolution()
  deviceNode.uiResolution = [uiRes.width, uiRes.height]
  ' video info below is based on the the Display type selected in the Roku settings which may or may not match the max playback resolution of the tv
  ' eg. if Display type is 1080p, these settings will be based on 1080p even if the TV supports 2160p/4K
  deviceNode.videoMode = videoMode
  deviceNode.videoHeight = StrToI(videoHeight)
  deviceNode.videoWidth = StrToI(videoWidth)
  deviceNode.videoRefresh = StrToI(refreshRate)
  deviceNode.videoBitDepth = bitDepth
  deviceNode.isLowMemoryDevice = checkIsLowMemoryDevice(deviceInfo.GetModel())

  m.global.addFields({ device: deviceNode })
end sub
