# Universal JellyRock Build Workflow
name: Build JellyRock App

on:
  workflow_call:
    inputs:
      build_type:
        description: "dev or prod?"
        required: false
        type: string
        default: "dev"
      upload_zip:
        description: "Upload release zip artifact?"
        required: false
        type: boolean
        default: false
      create_github_release:
        description: "Bump version and create draft GitHub release"
        required: false
        type: boolean
        default: false
    outputs:
      version:
        description: "Extracted version from manifest"
        value: ${{ jobs.build.outputs.version }}
      artifact_name:
        description: "Name of the uploaded artifact"
        value: ${{ jobs.build.outputs.artifact_name }}
      zip_name:
        description: "Name of the created zip file"
        value: ${{ jobs.build.outputs.zip_name }}
      branch_name:
        description: "Current branch name"
        value: ${{ jobs.build.outputs.branch_name }}
      build_context:
        description: "Build context (version_branch, main_branch, or feature_branch)"
        value: ${{ jobs.build.outputs.build_context }}

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.context.outputs.version }}
      artifact_name: ${{ steps.context.outputs.artifact_name }}
      zip_name: ${{ steps.context.outputs.zip_name }}
      branch_name: ${{ steps.context.outputs.branch_name }}
      build_context: ${{ steps.context.outputs.build_context }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          token: ${{ secrets.JELLYROCK_BOT_TOKEN || github.token }}
          fetch-tags: true
          fetch-depth: 0

      - name: Determine build context
        id: context
        run: |
          # Parse branch name properly for different GitHub contexts
          if [[ "$GITHUB_REF" == refs/pull/*/merge ]]; then
            # Pull request: extract PR number from refs/pull/123/merge
            PR_NUMBER=$(echo "$GITHUB_REF" | sed 's|refs/pull/||' | sed 's|/merge||')
            BRANCH_NAME="PR${PR_NUMBER}"
            RAW_BRANCH_NAME="$GITHUB_REF"
          elif [[ "$GITHUB_REF" == refs/heads/* ]]; then
            # Regular branch: remove refs/heads/ prefix
            BRANCH_NAME=${GITHUB_REF#refs/heads/}
            RAW_BRANCH_NAME="$BRANCH_NAME"
          else
            # Fallback for other ref types
            BRANCH_NAME=${GITHUB_REF##*/}
            RAW_BRANCH_NAME="$GITHUB_REF"
          fi

          MAJOR=$(sed -n 's/^major_version=//p' manifest)
          MINOR=$(sed -n 's/^minor_version=//p' manifest)  
          BUILD_VERSION=$(sed -n 's/^build_version=//p' manifest)
          VERSION="${MAJOR}.${MINOR}.${BUILD_VERSION}"

          # Determine artifact naming based on context and whether this is a release build
          if [[ "${{ inputs.create_github_release }}" == "true" ]]; then
            # Release builds use version-based naming
            if [[ $RAW_BRANCH_NAME =~ ^release-[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              BUILD_CONTEXT="version_branch"
              VERSION_TAG="v${RAW_BRANCH_NAME#release-}"  # Convert release-1.0.1 to v1.0.1
              ARTIFACT_NAME="JellyRock-${VERSION_TAG}-${{ github.sha }}"
              ZIP_NAME="JellyRock-${VERSION_TAG}.zip"
            elif [[ $RAW_BRANCH_NAME == "main" ]]; then
              BUILD_CONTEXT="main_branch"
              VERSION_TAG="v${VERSION}"  # Use manifest version for main branch
              TAG_NAME="v${VERSION}"
              ARTIFACT_NAME="JellyRock-${VERSION_TAG}-${{ github.sha }}"
              ZIP_NAME="JellyRock-${VERSION_TAG}.zip"
            fi
          else
            # Regular dev/prod builds use build_type-branch naming
            # Use the cleaned branch name for artifact naming
            SAFE_BRANCH=$(echo $BRANCH_NAME | sed 's/[^a-zA-Z0-9-]/-/g' | cut -c1-50)
            SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-8)
            ARTIFACT_NAME="JellyRock-${{ inputs.build_type }}-${SAFE_BRANCH}-${SHORT_SHA}"
            ZIP_NAME="JellyRock-${{ inputs.build_type }}-${SAFE_BRANCH}-${SHORT_SHA}.zip"
            
            if [[ $RAW_BRANCH_NAME =~ ^release-[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              BUILD_CONTEXT="version_branch"
            elif [[ $RAW_BRANCH_NAME == "main" ]]; then
              BUILD_CONTEXT="main_branch"
            else 
              BUILD_CONTEXT="feature_branch"
            fi
          fi

          echo "ðŸ” Build Context Information:"
          echo "  Raw Branch Ref: $RAW_BRANCH_NAME"
          echo "  Parsed Branch: $BRANCH_NAME"
          echo "  Version: $VERSION" 
          echo "  Build Context: $BUILD_CONTEXT"
          echo "  Artifact Name: $ARTIFACT_NAME"
          echo "  ZIP Name: $ZIP_NAME"

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "build_context=$BUILD_CONTEXT" >> $GITHUB_OUTPUT
          echo "artifact_name=$ARTIFACT_NAME" >> $GITHUB_OUTPUT
          echo "zip_name=$ZIP_NAME" >> $GITHUB_OUTPUT
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "major=$MAJOR" >> $GITHUB_OUTPUT
          echo "minor=$MINOR" >> $GITHUB_OUTPUT
          echo "build_version=$BUILD_VERSION" >> $GITHUB_OUTPUT

          # Set tag name for releases
          if [[ "${{ inputs.create_github_release }}" == "true" ]]; then
            if [[ $BUILD_CONTEXT == "version_branch" ]]; then
              TAG_NAME="v${RAW_BRANCH_NAME#release-}"  # Convert release-1.0.1 to v1.0.1
            elif [[ $BUILD_CONTEXT == "main_branch" ]]; then
              TAG_NAME="v${VERSION}"  # Use manifest version for main branch releases
            fi
            echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
            echo "  Tag Name: $TAG_NAME"
          fi

      - uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4
        with:
          node-version: "lts/*"
          cache: "npm"

      - name: Cache ropm dependencies
        uses: actions/cache@v4
        with:
          path: |
            source/roku_modules
            components/roku_modules
          key: ropm-${{ hashFiles('package.json', 'package-lock.json') }}
          restore-keys: ropm-

      - name: NPM install
        run: npm ci

      - name: Build application
        run: |
          if [[ "${{ inputs.build_type }}" == "prod" ]] || [[ "${{ steps.context.outputs.build_context }}" == "version_branch" ]]; then
            echo "ðŸ—ï¸ Building production version..."
            npm run build:prod
          else
            echo "ðŸ—ï¸ Building development version..."
            npm run build
          fi

      - name: Upload build artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: ${{ steps.context.outputs.artifact_name }}
          path: ${{ github.workspace }}/build/staging
          if-no-files-found: error

      - name: Rename and prepare ZIP for release
        if: ${{ inputs.upload_zip == 'true' || steps.context.outputs.build_context == 'version_branch' || (steps.context.outputs.build_context == 'main_branch' && inputs.create_github_release == true) }}
        run: |
          echo "ðŸ“¦ Preparing ZIP file for release..."
          if [[ -f "${{ github.workspace }}/out/jellyrock.zip" ]]; then
            cp "${{ github.workspace }}/out/jellyrock.zip" "${{ github.workspace }}/out/${{ steps.context.outputs.zip_name }}"
            echo "âœ… ZIP renamed to: ${{ steps.context.outputs.zip_name }}"
          else
            echo "âŒ Expected ZIP file not found at ./out/jellyrock.zip"
            ls -la ${{ github.workspace }}/out/ || echo "out directory not found"
            exit 1
          fi

      - name: Upload ZIP artifact
        if: ${{ inputs.upload_zip == 'true' || steps.context.outputs.build_context == 'version_branch' || (steps.context.outputs.build_context == 'main_branch' && inputs.create_github_release == true) }}
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: ${{ steps.context.outputs.zip_name }}
          path: ${{ github.workspace }}/out/${{ steps.context.outputs.zip_name }}
          if-no-files-found: error

      - name: Debug Release Condition
        run: |
          echo "ðŸ”§ Debug Release Condition:"
          echo "  inputs.create_github_release: '${{ inputs.create_github_release }}'"
          echo "  steps.context.outputs.build_context: '${{ steps.context.outputs.build_context }}'"
          echo "  inputs.create_github_release == true: ${{ inputs.create_github_release == true }}"
          echo "  steps.context.outputs.build_context == 'version_branch': ${{ steps.context.outputs.build_context == 'version_branch' }}"
          echo "  steps.context.outputs.build_context == 'main_branch': ${{ steps.context.outputs.build_context == 'main_branch' }}"
          echo "  Version branch condition: ${{ inputs.create_github_release == true && steps.context.outputs.build_context == 'version_branch' }}"
          echo "  Main branch condition: ${{ inputs.create_github_release == true && steps.context.outputs.build_context == 'main_branch' }}"
          echo "  Overall condition: ${{ inputs.create_github_release == true && (steps.context.outputs.build_context == 'version_branch' || steps.context.outputs.build_context == 'main_branch') }}"

      - name: Check and Delete Existing Release
        if: ${{ inputs.create_github_release == true && (steps.context.outputs.build_context == 'version_branch' || steps.context.outputs.build_context == 'main_branch') }}
        run: |
          TAG_NAME="${{ steps.context.outputs.tag_name }}"
          echo "ðŸ” Checking for existing release: $TAG_NAME"

          # Check if release exists
          RELEASE_ID=$(gh release view "$TAG_NAME" --json id --jq '.id' 2>/dev/null || echo "")

          if [[ -n "$RELEASE_ID" ]]; then
            echo "ðŸ—‘ï¸ Deleting existing release: $TAG_NAME (ID: $RELEASE_ID)"
            gh release delete "$TAG_NAME" --yes
            echo "âœ… Existing release deleted"
          else
            echo "â„¹ï¸ No existing release found for tag: $TAG_NAME"
          fi
        env:
          GH_TOKEN: ${{ secrets.JELLYROCK_BOT_TOKEN }}

      - name: Generate Changelog Entry
        if: ${{ inputs.create_github_release == true && (steps.context.outputs.build_context == 'version_branch' || steps.context.outputs.build_context == 'main_branch') }}
        run: |
          echo "ðŸ“ Generating changelog for release ${{ steps.context.outputs.tag_name }}"

          # Get the latest tag to compare against
          LATEST_TAG=$(git tag --sort=-v:refname | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | head -n 1 || echo "")

          if [[ -n "$LATEST_TAG" ]]; then
            echo "ðŸ“Š Converting unreleased changes to release ${{ steps.context.outputs.version }}"
            node scripts/changelog-syncer.js sync-release "${{ steps.context.outputs.version }}"
          else
            echo "ðŸ“Š Creating initial release changelog entry"
            node scripts/changelog-syncer.js sync-release "${{ steps.context.outputs.version }}"
          fi

      - name: Extract Release Notes from Changelog
        if: ${{ inputs.create_github_release == true && (steps.context.outputs.build_context == 'version_branch' || steps.context.outputs.build_context == 'main_branch') }}
        id: release_notes
        run: |
          echo "ðŸ“– Extracting release notes for ${{ steps.context.outputs.version }}"

          # Extract the section for this version from CHANGELOG.md
          VERSION_PATTERN="## \[${{ steps.context.outputs.version }}\]"

          if grep -q "$VERSION_PATTERN" CHANGELOG.md; then
            # Get content between this version and the next version/end of file
            # Use more flexible pattern to handle URL-based headers like [1.0.1](https://...)
            RELEASE_NOTES=$(awk "/^## \[${{ steps.context.outputs.version }}\]/{flag=1; next} /^## \[.*\]/{if(flag) exit} flag" CHANGELOG.md)
          else
            # Fallback to a simple release note
            RELEASE_NOTES="JellyRock ${{ steps.context.outputs.tag_name }} release.

          See [CHANGELOG.md](https://github.com/cewert/jellyrock/blob/main/CHANGELOG.md) for details."
          fi

          # Save to file for multi-line output
          echo "$RELEASE_NOTES" > /tmp/release_notes.md

          echo "ðŸ“‹ Release notes preview:"
          cat /tmp/release_notes.md

          # Set output for use in release creation
          {
            echo "notes<<EOF"
            cat /tmp/release_notes.md
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Create GitHub Release
        if: ${{ inputs.create_github_release == true && (steps.context.outputs.build_context == 'version_branch' || steps.context.outputs.build_context == 'main_branch') }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.context.outputs.tag_name }}
          name: ${{ steps.context.outputs.tag_name }}
          body: |
            ## Release Schedule

            JellyRock ${{ steps.context.outputs.tag_name }} is scheduled for release on the Roku App Store **DATE_TIME**.

            ${{ steps.release_notes.outputs.notes }}
          draft: true
          prerelease: false
          generate_release_notes: false
          discussion_category_name: Announcements
          token: ${{ secrets.JELLYROCK_BOT_TOKEN }}
          files: ${{ github.workspace }}/out/${{ steps.context.outputs.zip_name }}
